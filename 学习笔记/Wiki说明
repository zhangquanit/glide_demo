------------------------缓存和缓存失效
1、Cache Keys
Cache Keys用于DiskCacheStrategy.RESULT，主要由四部分组成：
1）DataFetcher.getId()
2）override(int, int)设置的width和height
默认使用的是 Target's getSize()返回的
3）各种encoders或decoders的getId()
4）指定的signature
最后hash处理

2、缓存失效
因为缓存文件名都是经过hash计算的，所以根据url或file path去删除相应的缓存文件就变得比较困难。
复杂性主要是Glide会缓存很多文件，比如一张图片就会缓存原始图片，缩略图，还有各种transformations效果图片
所以要删除某个url对应的所有缓存图片就比较困难。


3、自定义缓存失效
1）Media store content
MediaStoreSignature
2)Files
StringSignature
3)Urls

Glide.with(yourFragment)
    .load(yourFileDataModel)
    .signature(new StringSignature(yourVersionMetadata))
    .into(yourImageView);

Glide.with(fragment)
    .load(mediaStoreUri)
    .signature(new MediaStoreSignature(mimeType, dateModified, orientation))
    .into(view);

---------------------------配置
1、创建GlideModule
实现GlideModule接口，比如Okhttp3
public class OkHttpGlideModule implements GlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    // Do nothing.
  }

  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
  }
}
2、添加混淆配置
3、在manifest.xml中注册GlideModule
GlideModules可实现多个，但是都必须注册
4、全局配置 GlideBuilder
重写GlideModule.applyOptions(GlideBuilder)
1)builder.setDiskCache 设置硬盘缓存
--内部缓存
new InternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes)
默认就是使用的内部缓存，大小为250MB，文件夹名image_manager_disk_cache
 File cacheDirectory = context.getCacheDir();
 new File(cacheDirectory, diskCacheName); //diskCacheName默认是image_manager_disk_cache
--外部缓存
new ExternalCacheDiskCacheFactory(context, cacheDirectoryName, yourSizeInBytes)
--DiskLruCacheFactory

builder.setDiskCache(new InternalCacheDiskCacheFactory(context, "glide",300*1024*1024));
builder.setDiskCache(new ExternalCacheDiskCacheFactory(context,"glide",300*1024*1024));
builder.setDiskCache(new DiskLruCacheFactory("glide",300*1024*1024));

2)设置内存缓存大小和BitmapPool
builder.setMemoryCache(new LruResourceCache(yourSizeInBytes));
builder.setBitmapPool(new LruBitmapPool(sizeInBytes));

 MemorySizeCalculator calculator = new MemorySizeCalculator(context);
 int defaultMemoryCacheSize = calculator.getMemoryCacheSize();
 int defaultBitmapPoolSize = calculator.getBitmapPoolSize();

 当然也可以通过setMemoryCategory动态调整
 Glide.get(context).setMemoryCategory(MemoryCategory.HIGH);

3)Bitmap Format
默认是DecodeFormat DEFAULT = PREFER_RGB_565; 每个像素占2个字节
builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);

RGB_565
R 5bit G 6bit B 5bit
总共5+6+5=16 bit=2byte,也就是每个像素占2个字节

ARGB_8888
Alpha通道 8bit R 8bit G 8bit B 8bit
总共8+8+8+8=32 bit=4byte,也就是每个像素占4个字节


---------------------------Custom targets
一、SimpleTarget
比如只是加载一个Bitmap
int myWidth = 512;
int myHeight = 384;
Glide.with(yourApplicationContext))
    .load(youUrl)
    .asBitmap()
    .into(new SimpleTarget<Bitmap>(myWidth, myHeight) {
        @Override
        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {
            // Do something with bitmap here.
        }
    };
特别说明下
Glide.with(context)
context如果是Activity或Fragment，则Activity或Fragment onStop时会自动停止请求，onStart时继续
如果是一个后台请求，则建议使用ApplicationContext，避免造成Activity或Fragment的内存泄露

二、ViewTarget
重写ViewTarget，自己给View设置Resource
Glide.with(yourFragment)
    .load(yourUrl)
    .into(new ViewTarget<YourViewClass, GlideDrawable>(yourViewObject) {
        @Override
        public void onResourceReady(GlideDrawable resource, GlideAnimation anim) {
            YourViewClass myView = this.view;
            // Set your resource on myView and/or start your animation here.
        }
    });

也可以监听Target的start，stop，destroy
Glide.with(this)
    .load("")
    .into(new ViewTarget<ImageView, GlideDrawable>(imageView) {
        @Override
        public void onResourceReady(GlideDrawable resource, GlideAnimation anim) {
            ImageView imageView = this.view;
            imageView.setImageDrawable(resource);
            // Set your resource on myView and/or start your animation here.
        }

        @Override
        public void onStart() {
            super.onStart();
        }

        @Override
        public void onStop() {
            super.onStop();
        }

        @Override
        public void onDestroy() {
            super.onDestroy();
        }

        @Override
        public void onLoadFailed(Exception e, Drawable errorDrawable) {
            super.onLoadFailed(e, errorDrawable);
        }
    });
Activity或Fragemnt onStop或onStart会回调Target

如果你想指定Bitmap或GifDrawable，需要在.load()后调用.asBitmap() or .asGif()
  //加载bitmap
Glide.with(this)
        .load("")
        .asBitmap()
        .into(new ViewTarget<ImageView, Bitmap>(imageView) {
            @Override
            public void onResourceReady(Bitmap resource, GlideAnimation anim) {
                ImageView imageView = this.view;
                imageView.setImageBitmap(resource);
                // Set your resource on myView and/or start your animation here.
            }
        });
//加载Gif
Glide.with(this)
        .load("")
        .asGif()
        .into(new ViewTarget<ImageView, GifDrawable>(imageView) {
            @Override
            public void onResourceReady(GifDrawable resource, GlideAnimation anim) {
                ImageView imageView = this.view;
                imageView.setImageDrawable(resource);
                // Set your resource on myView and/or start your animation here.
            }
        });
三、Overriding default behavior
 观察ImageViewTargets
BitmapImageViewTarget ：调用asBitmap()后的默认Target
GlideDrawableImageViewTarget : 正常load()或调用 asGif()后的Target

public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z> implements GlideAnimation.ViewAdapter {

    public ImageViewTarget(ImageView view) {
        super(view);
    }
    @Override
    public Drawable getCurrentDrawable() {
        return view.getDrawable();
    }
    @Override
    public void setDrawable(Drawable drawable) {
        view.setImageDrawable(drawable);
    }
    @Override
    public void onLoadStarted(Drawable placeholder) {
        view.setImageDrawable(placeholder);
    }
    @Override
    public void onLoadFailed(Exception e, Drawable errorDrawable) {
        view.setImageDrawable(errorDrawable);
    }
    @Override
    public void onLoadCleared(Drawable placeholder) {
        view.setImageDrawable(placeholder);
    }
    @Override
    public void onResourceReady(Z resource, GlideAnimation<? super Z> glideAnimation) {
        if (glideAnimation == null || !glideAnimation.animate(resource, this)) {
            setResource(resource);
        }
    }
    protected abstract void setResource(Z resource);
}

public class BitmapImageViewTarget extends ImageViewTarget<Bitmap> {
    public BitmapImageViewTarget(ImageView view) {
        super(view);
    }
    @Override
    protected void setResource(Bitmap resource) {
        view.setImageBitmap(resource); //设置bitmap
    }
}

四、Palette example



--------------------------------调试和错误处理
一、Debugging

二、RequestListener 处理错误
Glide.with(this)
     .load("")
     .listener(new LoggingListener<String, GlideDrawable>())

//记录日志
public class LoggingListener<T, R> implements RequestListener<T, R> {
    @Override public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) {
        android.util.Log.d("GLIDE", String.format(Locale.ROOT,
                "onException(%s, %s, %s, %s)", e, model, target, isFirstResource), e);
        return false;
    }
    @Override public boolean onResourceReady(Object resource, Object model, Target target, boolean isFromMemoryCache, boolean isFirstResource) {
        android.util.Log.d("GLIDE", String.format(Locale.ROOT,
                "onResourceReady(%s, %s, %s, %s, %s)", resource, model, target, isFromMemoryCache, isFirstResource));
        return false;
    }
}


--------------------------------Downloading custom sizes
public interface MyDataModel {
    public String buildUrl(int width, int height);
}

public class MyUrlLoader extends BaseGlideUrlLoader<MyDataModel> {
    @Override
    protected String getUrl(MyDataModel model, int width, int height) {
        // Construct the url for the correct size here.
        return model.buildUrl(width, height);
    }
}

Glide.with(yourFragment)
    .using(new MyUrlLoader())
    .load(yourModel)
    .into(yourView);

如果不想每次都调用.using(new MyUrlLoader())，可以实现ModelLoaderFactory ，然后在GlideModule中注册
public class MyGlideModule implements GlideModule {
    ...
    @Override
    public void registerComponents(Context context, Glide glide) {
        glide.register(MyDataModel.class, InputStream.class,
            new MyUrlLoader.Factory());
    }
}
之后，就不用在每个请求中调用.using()
Glide.with(yourFragment)
    .load(yourModel)
    .into(yourView);

---------------------------整合Volley、OkHttp

---------------------------在后台线程中加载和缓存
downloadOnly(int, int)
into(int, int)

下载图片然后缓存到本地硬盘上，以便之后使用

一、downloadOnly

1、downloadOnly(width,height) 异步下载
FutureTarget<File> future = Glide.with(applicationContext)
    .load(yourUrl)
    .downloadOnly(500, 500);

如果要获取返回值的话，需要在子线程获取，因为future.get()会阻塞主线程
 new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    File cacheFile = future.get();//这个方法必须在后台线程中执行，当future返回了，则表示文件下载好了，可以使用缓存了。
                    System.out.println("downloadOnly(width,height)....cacheFile="+cacheFile);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();

注注意：避免引起内存泄露，使用ApplicationContext

因此在后台线程或加载图片并获取返回值的写法：
new Thread(new Runnable(){
   @override
   public void run(){
         FutureTarget<File> future = Glide.with(applicationContext)
             .load(yourUrl)
             .downloadOnly(500, 500);
         File cacheFile = future.get();
   }
)).start();

2、downloadOnly(target) 异步下载,回调到主线程中
Glide.with(getApplicationContext())
        .load(imgUrls[2])
        .downloadOnly(new SimpleTarget<File>() {
            @Override
            public void onResourceReady(File resource, GlideAnimation<? super File> glideAnimation) {
                Bitmap bitmap = BitmapFactory.decodeFile(resource.getAbsolutePath());
                System.out.println("downloadOnly（target），bitmap="+bitmap+",thread="+Thread.currentThread().getName());
            }
        });

使用缓存：
Glide.with(yourFragment)
    .load(yourUrl)
    .diskCacheStrategy(DiskCacheStrategy.ALL)
    .into(yourView);
通过设置缓存策略：DiskCacheStrategy.ALL 或 DiskCacheStrategy.SOURCE，可以确保加载刚才缓存的图片。

二、into
下载一个500x500像素，centerCrop的图片
new Thread(new Runnable(){
   @override
   public void run(){
        Bitmap myBitmap = Glide.with(applicationContext)
            .load(yourUrl)
            .asBitmap()
            .centerCrop()
            .into(500, 500)
            .get()  // get()会阻塞主线程，不能在主线程中使用
   }
)).start();





















